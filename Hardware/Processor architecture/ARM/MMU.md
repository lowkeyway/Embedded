# MMU

## 简介

MMU(Memory Management Unit)，它负责虚拟地址到物理地址的映射，并提供硬件机制的内存访问权限检查。现代的多用户多进程操作系统通过MMU使得各个用户进程都拥有自己独立的地址空间：地址映射功能使得各进程拥有“看起来”一样的地址空间，而内存访问权限的检查可以保护每个进程所用的内存不会被其他进程破坏。

## 为什么需要MMU

在许多年以前，还是使用DOS或一些古老的操作系统时，内存很小，同时，应用程序也很小，将程序存储在内存中基本能够满足需要。随着科技的发展，图形界面及一些其他更复杂的应用出现，内存已经无法存储这些应用程序了，通常的解决办法是将程序分割成很多个覆盖块，覆盖块0最先运行，运行结束之后，就调用另一个覆盖块，虽然这些操作由OS来完成，但是，需要程序员对程序进行分割，这非常不高效；因此，人们想出了一个虚拟存储器（virtual memory）的方法。虚拟存储器的基本思想是：程序、数据、堆栈的总大小可以超过内存空间的大小，操作系统将当前运行的部分保存在内存中，未使用的部分保存在磁盘中。比如一个16MB的程序和一个内存只有4MB的机器，操作系统通过选择可以决定哪部分4MB的程序内容保存在内存中，并在需要时，在内存与磁盘中交换程序代码，这样16MB的代码就可以运行在4MB的机器中了。注意：这里面包含了虚拟地址和物理地址的概念。

## MMU的作用机制

在介绍MMU的作用机制之前，我们先来了解几组概念：
+ 概念：


  + 地址范围： 指处理器能够产生的地址集合，如一个32bit的处理器ARM9，其能产生的地址集合是0x0000 0000 ~ 0xffff ffff(4G)，这个地址范围也称为虚拟地址空间，其中对应的地址为虚拟地址。
  + 虚拟地址与物理地址： 与虚拟地址空间和虚拟地址相对应的是物理地址空间和物理地址；物理地址空间只是虚拟地址空间的一个子集。如一台内存为256MB的32bit X86主机，其虚拟地址空间是0 ~ 0xffffffff(4GB)，物理地址空间范围是0 ~ 0x0fff ffff(256M)
  + 分页机制：
    + 如果处理器没有MMU，或者有MMU但没有启用，CPU执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为物理地址（Physical Address，以下简称PA）
    <img src="https://github.com/lowkeyway/Embedded/blob/master/Hardware/Processor%20architecture/ARM/Picture/%E6%B2%A1%E6%9C%89MMU.png">
    
    + 如果处理器启用了MMU，CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将VA映射成PA：
    <img src="https://github.com/lowkeyway/Embedded/blob/master/Hardware/Processor%20architecture/ARM/Picture/%E6%9C%89MMU.png">
    
    + 大多数使用MMU的机器都采用分页机制。虚拟地址空间以页为单位进行划分，而相应的物理地址空间也被划分，其使用的单位称为页帧，页帧和页必须保持相同，因为内存与外部存储器之间的传输是以页为单位进行传输的。例如，MMU可以通过一个映射项将VA的一页0xb70010000xb7001fff映射到PA的一页0x20000x2fff，如果CPU执行单元要访问虚拟地址0xb7001008，则实际访问到的物理地址是0x2008。虚拟内存的哪个页面映射到物理内存的哪个页帧是通过页表（Page Table）来描述的，页表保存在物理内存中，MMU会查找页表来确定一个VA应该映射到什么PA。
+ 实现：

MMU的实现过程，实际上就是一个查表映射的过程。建立页表（translate table）是实现MMU功能不可缺少的一步。页表是位于系统的内存中，页表的每一项对应于一个虚拟地址到物理地址的映射。每一项的长度即是一个字的长度（在ARM中，一个字的长度被定义为4字节）。页表项除完成虚拟地址到物理地址的映射功能之外，还定义了访问权限和缓冲特性等。
  + 映射存储块的分类
  
    - 节 （ Section ） 构成 1MB 的存储器块
    - 大页 （ Large page ） 构成 64KB 的存储器块
    - 小页 （ Small page ） 构成 4KB 的存储器块
    - 微页 （ Tiny page ） 构成 1KB 的存储器块
    
    MMU 支持基于节或页的存储器访问， MMU 可以用上面四种大小进行映射，其中对于节映射使用一级转换表就可以了，而对于微页、小页、大页则需要使用两级转换表

+ 转换过程

要知道虚拟内存机制必须了解ARM9中的3种地址：VA（虚地址），MVA（修正后虚地址），PA（物理地址）
1. VA，是程序中的逻辑地址，0x00000000~0xFFFFFFFF。
2. MVA，是修改后的虚拟地址。在ARM9里面，如果VA<32M，利用进程标识号PID转换得到MVA。过程如下：

```C
if(VA < 32M)
     MVA = VA | ( PID<<25 )
else
     MVA = VA
```

只是上面的过程是由硬件实现的。这样为VA进行了一级映射，为什么呢？在linux系统里，每个进程的地址空间0-4G，0-3G是进程独有的，称为用户空间，3G-4G是系统的，称为内核空间，所有进程共享。如果两个进程所用的VA有重叠，在切换进程时，为了把重叠的VA映射到不同的PA上，需要重建页表、使无效caches和TLBS。使用了MVA，使进程在VA相同的情况下，使用不同的MVA，进而PA也不同。这就是在VA与PA之间加上一次到MVA的映射的意义。

3. PA，物理地址，MVA通过MMU转换后的地址
<img src="https://github.com/lowkeyway/Embedded/blob/master/Hardware/Processor%20architecture/ARM/Picture/%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B.png">


将一个虚拟地址转换成物理地址，一般有两种方法：
1. 用一个确定的数学公式进行转换
2. 用表格存储虚拟地址对应的物理地址。这类表格称为页表（Page Table）， 页表由一个个条目（Entry）组成；每个条目存储了一段虚拟地址对应的物理地址及其访问权限，或下一级页表的地址

ARM采用的就是第二种方式（其实就是写信用的XX省XX市XX区XX小区的格式）。一般来说，最多用到两级页表
  + 以段（Section， 1MB）的方式进行转换时只用到一级页表
  + 以页（Page）的方式转换时用到两级页表，而页的大小有三种
    - 大页（64KB）
    - 小页（4KB）
    - 极小页（1KB）
  + 条目也被称作“描述符”（Descriptor），分为：
    - 段描述符（保存段的起始物理地址）
    - 大页描述符（保存大页的起始物理地址
    - 小页描述符（保存小页的起始物理地址）
    - 极小页描述符（保存极小页的起始物理地址）
    - 粗页表描述符（保存二级页表的物理地址）
    - 细页表描述符（保存二级页表的物理地址）
    
了解了这么多概念后，MMU把VA转换成PA的过程就显得非常简单了：
1. 根据指定的虚拟地址找到一级页表中的条目；
2. 如果此条目是段描述符，则返回物理地址，转换结束；
3. 否则如果此条目是二级页描述符，继续利用虚拟地址在此二级条目上找到下一个条目；
4. 如果这第二个条目是页描述符，则返回物理地址，转化结束；
5. 其他情况出错；

<img src="https://github.com/lowkeyway/Embedded/blob/master/Hardware/Processor%20architecture/ARM/Picture/%E4%B8%80%E7%BA%A7%E9%A1%B5%E8%A1%A8.png">
<img src="https://github.com/lowkeyway/Embedded/blob/master/Hardware/Processor%20architecture/ARM/Picture/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.png">


