本文以问答的方式来看一看操作系统的知识领域里，一般需要关注什么问题。

#  1. 操作系统基础
## 1.1 什么是操作系统？

+ 1. 操作系统（Operating System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；
+ 2. 操作系统本质上是运行在计算机上的软件程序 ；
+ 3. 操作系统为用户提供一个与系统交互的操作界面 ；
+ 4. 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核可以理解为能直接操作硬件的程序）。


关于内核多插一嘴：
内核负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。内核就是操作系统背后黑盒的核心。  

<img src="https://github.com/lowkeyway/Embedded/blob/master/Software/OS/Pic/00_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E5%92%8C%E5%A4%96%E5%A3%B3.png">  

## 1.2 系统调用

介绍系统调用之前，我们先来了解一下用户态和系统态。  
根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：  
+ 1. 用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。
+ 2. 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。  

说了用户态和系统态之后，那么什么是系统调用呢？  

我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！  

也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。  

这些系统调用按功能大致可分为如下几类：
+ 设备管理。完成设备的请求或释放，以及设备启动等功能。
+ 文件管理。完成文件的读、写、创建及删除等功能。  
+ 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
+ 进程通信。完成进程之间的消息传递或信号传递等功能。
+ 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

# 2 进程和线程[参考](https://blog.csdn.net/u012218309/article/details/81912074)

首先明确一点，linux对进程和线程不做区分，统一由task_struct来管理所有进程和线程。  
那么如何在linux下区分进程和线程呢？  

## 2.1 为什么要引入线程的概念？

一个进程包含很多系统资源：进程控制块、虚存空间、文件系统，文件I/O、信号处理函数，创建一个进程的过程就是这些资源被创建的过程。  

系统调用fork创建一个进程时子进程是一段独立的内存空间，其中的资源是父进程资源的副本，两个进程是完全独立不共享内存资源的，二者需要通过IPC进行通信。  

这样的做法在有些场景下并不是高效的做法，例如：比如某进程fork出一个子进程后，其子进程仅仅是为了调用exec执行另一个执行文件，那么在fork过程中对于内存空间的复制就是多余的；再例如：如果通过这种方式处理并行计算问题，那么就得在不同cpu创建不同的进程，然后通过IPC再把计算结果汇总，这样做的开销往往足以抵消并行计算带来的好处。  

另外，进程是系统中程序执行和资源分配的基本单元，每个进程都拥有自己的数据段、代码段和堆栈段，进程进行切换时都会伴随着上下文的切换，这也会带来开销。  

所以把计算单元抽象到进程上是不充分的，这也就是许多系统中都引入了线程的概念的原因。  

## 2.2 Linux怎么创建进程？  

Linux创建进程一共有三种方式：fork  vfork  clone。三个函数分别通过sys_fork()、sys_vfork()和sys_clone()调用do_fork()去做具体的创建工作，只不过传入的参数不同。  

** sys_fork()： **
```
asmlinkage long sys_fork(struct pt_regs regs)
 
{
 
    return do_fork(SIGCHLD, regs.rsp, &regs, 0);
 
}
```
传入的参数SIGCHLD表示在子进程终止后将发送信号SIGCHLD信号通知父进程。


** sys_vfork()： **
```
asmlinkage long sys_vfork(struct pt_regs regs)
 
{
 
    return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.rsp, &regs, 0);
 
}
```

** sys_clone()： **
```
casmlinkage int sys_clone(struct pt_regs regs)
 
{
 
    unsigned long clone_flags;
 
    unsigned long newsp;
 
 
 
    clone_flags = regs.ebx;
 
    newsp = regs.ecx;
 
    if (!newsp)
 
        newsp = regs.esp;
 
    return do_fork(clone_flags, newsp, &regs, 0);
 
}
```

## Linux怎么创建线程？




https://mp.weixin.qq.com/s/MfLE6TrjlCeH3xT1YSATHg
