# Linux 块设备

+ 块设备驱动要远比字符设备驱动复杂得多，不同类型的存储设备又对应不同的驱动子系统
+ 块设备是针对存储设备的，比如 SD 卡、EMMC、NAND Flash、Nor Flash、SPI Flash、机械硬盘、固态硬盘等。
+ 因此块设备驱动其实就是这些存储设备驱动，块设备驱动相比字符设备驱动的主要区别如下：
  + 块设备只能以块为单位进行读写访问，块是 linux 虚拟文件系统(VFS)基本的数据传输单位。
  + 块设备在结构上是可以进行随机访问的，对于这些设备的读写都是按块进行的，块设备使用缓冲区来暂时存放数据，等到条件成熟以后在一次性将缓冲区中的数据写入块设备中。

+ 这么做的目的为了提高块设备寿命，为了提高块设备寿命而引入了缓冲区，数据先写入到缓冲区中，等满足一定条件后再一次性写入到真正的物理存储设备中，这样就减少了对块设备的擦除次数，提高了块设备寿命。
+ 字符设备是以字节为单位进行数据传输的，不需要缓冲。
+ 字符设备是顺序的数据流设备，字符设备是按照字节进行读写访问的。字符设备不需要缓冲区，对于字符设备的访问都是实时的，而且也不需要按照固定的块大小进行访问。
+ linux 内核使用 block_device 表示块设备， block_device 为 一 个 结 构 体 ， 定 义 在include/linux/fs.h 文件
+ bd_disk 成员变量，此成员变量为gendisk 结构体指针类型
+ linux 内核使用 gendisk 来描述一个磁盘设备，这是一个结构体，定义在 include/linux/genhd.h
+ 编写块的设备驱动的时候需要分配并初始化一个 gendisk，linux 内核提供了一组 gendisk 操作函数
+ 块设备也有操作集，为结构体 block_device_operations，此结构体定义在 include/linux/blkdev.h

## 块设备 I/O 请求过程:

### 请求队列 request_queue
+ 内核将对块设备的读写都发送到请求队列 request_queue 中，request_queue 中是大量的request(请求结构体)，
+ 而 request 又包含了 bio，bio 保存了读写相关数据，比如从块设备的哪个地址开始读取、读取的数据长度，读取到哪里，如果是写的话还包括要写入的数据等。
+ request_queue，定义在文件 include/linux/blkdev.h
+ gendisk结构体就会发现里面有一个 request_queue 结构体指针类型成员变量 queue，也就说在编写块设备驱动的时候，每个磁盘(gendisk)都要分配一个 request_queue。
+ 一般 blk_alloc_queue 和 blk_queue_make_request 是搭配在一起使用的，用于那么非机械的存储设备、无需 I/O 调度器，比如 EMMC、SD 卡等。
+ blk_init_queue 函数会给请求队列分配一个 I/O 调度器，用于机械存储设备，比如机械硬盘等
+ 请求队列(request_queue)里面包含的就是一系列的请求(request)，request 是一个结构体，定义在 include/linux/blkdev.h
+ request 里面有一个名为“bio”的成员变量，类型为 bio 结构体指针。
+ 真正的数据就保存在 bio 里面，所以需要从 request_queue 中取出一个一个的 request，
+ 然后再从每个 request 里面取出 bio，
+ 最后根据 bio 的描述讲数据写入到块设备，或者从块设备中读取数据。
+ 每个 request 里面里面会有多个 bio，bio 保存着最终要读写的数据、地址等信息。
+ 上层应用程序对于块设备的都写会被构造成一个或多个 bio 结构，bio 结构描述了要读写的起始扇区、要读写的扇区数量、是读取还是写入、页便宜、数据长度等等信息。
+ 上层会将 bio 提交给 I/O 调度器，I/O 调度器会将这些 bio 构造成 request 结构，而一个物理存储设备对应一个 request_queue，request_queue 里面顺序存放着一系列的 request。
+ 新产生的 bio 可能被合并到 request_queue 里现有的 request 中，也可能产生新的 request，然后插入到 request_queue 中合适的位置，这一切都是由 I/O 调度器来完成的
+ bio 是个结构体，定义在 include/linux/blk_types.h 中
+ bvec_iter 结构体描述了要操作的设备扇区等信息
+ 可以看出 bio_vec 就是“page,offset,len”组合，page 指定了所在的物理页，offset 表示所处页的偏移地址，len 就是数据长度。
+ 对于物理存储设备的操作不外乎就是将 RAM 中的数据写入到物理存储设备中，或者将物理设备中的数据读取到 RAM 中去处理
+ 数据传输三个要求：数据源、数据长度以及数据目的地，也就是你要从物理存储设备的哪个地址开始读取、读取到 RAM 中的哪个地址处、读取的数据长度是多少
+ 既然 bio 是块设备最小的数据传输单元，那么 bio 就有必要描述清楚这些信息，
+ 其中 bi_iter 这个结构体成员变量就用于描述物理存储设备地址信息，比如要操作的扇区地址。
+ bi_io_vec 指向 bio_vec 数组首地址，bio_vec 数组就是 RAM 信息，比如页地址、页偏移以及长度，“页地址”是 linux 内核里面内存管理相关的概念，这里 linux 内存管理暂不深究，只需要知道对于 RAM 的操作最终会转换为页相关操作
