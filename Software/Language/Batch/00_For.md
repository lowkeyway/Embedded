# 一、前言

在批处理中，for是最为强大的命令语句，它的出现，使得解析文本内容、遍历文件路径、数值递增/递减等操作成为可能；配合if、call、 goto等流程控制语句，更是可以实现脚本复杂的自动化、智能化操作；合理使用for语句，还能使代码大为简化，免除各位编写大量重复语句之苦。而能否熟 练使用for语句，已经成为衡量一个人批处理水平高低最主要的标准。  

# 二、for语句的基本用法

正如色彩缤纷的七彩光芒是由红绿蓝三原色构成的一样，最复杂的for语句，也有其基本形态，它的模样是这样的：
在cmd窗口中：
```
FOR %variable IN (set) DO command [command-parameters]
```

在批处理文件中：
```
FOR %%variable IN (set) DO command [command-parameters]
```

具体例子：
```
C:\Users\louli>For %i in (1 2 3) do @echo %i
1
2
3
```

之所以要区分cmd窗口和批处理文件两种环境，是因为在这两种环境下，命令语句表现出来的行为虽然基本一样，但是在细节上还是稍有不同。  
最明显的一个差异就是：在cmd窗口中，for之后的形式变量I必须使用单百分号引用，即%i；而在批处理文件中，引用形式变量i必须使用双百分号，即%%i。  


我们先来看一下for语句的基本要素都有些什么：  
+ 1、for、in和do是for语句的关键字，它们三个缺一不可；  
+ 2、%%I是for语句中对形式变量的引用，就算它在do后的语句中没有参与语句的执行，也是必须出现的；  
+ 3、in之后，do之前的括号不能省略；  
+ 4、command-parameters表示字符串或变量，command表示字符串、变量或命令语句；  

现在，你可能已经会写一个简单的for语句了，比如：  
[code1]
```
@echo off
for %%I in (bbs.bathome.net) do echo %%I
pause
```


保存为批处理文件并执行，将会在弹出的批处理窗口中看到这样的信息：
```
bbs.bathome.net
Press any key to continue . . .
```

很快地，你会觉得这个for语句是如此的简单，简单到你丝毫感受不出它的强大：这个for语句，和我直接用echo语句没什么两样啊！  
是的，演示代码永远都只是演示而已，就像大多数高级语言的教科书一样，在引导新手学习的时候，基本上都是千篇一律地告诉大家如何编写一个能显示 hello world! 的窗口，从这些演示代码中，你看不到它们具有多少实用性，你只是感到有点好奇：咦，居然弹出了一个窗口？片刻之后，你就会觉得索然无味。  

那好吧，为了让大家对for更加感兴趣，我们先来分析一下for语句的一些注意事项，之后，再让大家看看更为强大的for语句实例。

+ 1、for语句的形式变量I，可以换成26个字母中的任意一个，这些字母会区分大小写，也就是说，%%I和%%i会被认为不是同一个变量；形式变量I还可以换成其他的字符，但是，为了不与批处理中的%0～%9这10个形式变量发生冲突，请不要随意把%%I替换为%%0 ～%%9中的任意一个；  
+ 2、in和do之间的command1表示的字符串或变量可以是一个，也可以是多个，每一个字符串或变量，我们称之为一个元素，每个元素之间，用空格键、跳格键、逗号、分号或等号分隔；  
+ 3、for语句依次提取command1中的每一个元素，把它的值赋予形式变量I，带到do后的command2中参与命令的执行；并且每次只提取一个元 素，然后执行一次do后的命令语句，而无论这个元素是否被带到command2中参与了command2的运行；当执行完一次do后的语句之后，再提取 command1中的下一个元素，再执行一次command2，如此循环，直到command1中的所有元素都已经被提取完毕，该for语句才宣告执行结 束；  

其中，第3点是最为关键的，它描述了for语句的执行过程，是for语句的精髓所在，大家一定要牢记这一条，才能深刻理解更为复杂的for流程。

有了以上的基础，我们再来看一个例子，这个例子修改了[code1]的部分内容，结果将大不一样：  
[code2]
```
@echo off
for %%I in (bbs,bathome,net) do echo %%I
pause
```

[Result2]：
```
bbs
bathome
net
Press any key to continue . . .
```
和[code1]的执行结果[result1]相比，[result2]发生了如下变化：
+ 1、显示结果分成了3行(不算最后一行提示)；
+ 2、每一行都从逗号处被切分；

如果把 bbs.bathome.net 这个字符串中的点号换为空格、跳格或等号，执行结果将和example2的执行结果别无二致。  
现在，我们来分析一下[code2]代码中for语句的执行过程：  
**首先**，for语句以逗号为分隔符，把 bbs,bathome.net 这个字符串切分成三个元素：bbs、bathome和cn，由此决定了do后的语句将会被执行3次；  
**然后**，第一次执行过程是这样的：先把 bbs 这个字符串作为形式变量I的值，带入do后的语句中加以执行，也就是执行 echo %%I 语句，此时的I值为bbs，因此，第一次执行的结果，将会在屏幕上显示bbs这个字符串；第二次执行和第一次执行的过程是一样的，只不过此时I的值已经被替换为command1中的第二个元素了，也就是 bathome 这个字符串；如此循环，当第三次echo执行完毕之后，整条for语句才算执行完毕，此时，将执行下一条语句，也就是pause命令。  

为了让大家见识一下for的真正威力，本人绞尽脑汁，翻帖无数，不得要领，万般无奈之下，只好亮出了尘封在箱底多年的一段代码：检测当前硬盘都有哪些分区。  
[code3]
```
@echo off
set str=c d e f g h i j k l m n o p q r s t u v w x y z
echo The disk this PC have:
for %%i in (%str%) do if exist %%i: echo %%i:
pause
```  
[Result3]
```
The disk this PC have:
c:
Press any key to continue . . .
```

这段代码能检测硬盘都有哪些分区，包括U盘和移动硬盘的分区，但是，当光驱中有盘的时候，也会被列出来，这是本代码的一个缺憾，在以后的讲解中，我将向大家讲述如何消除这个瑕疵，敬请关注本系列的后续章节。

## 高级应用：
想知道当前目录下都有哪些文件吗？请用下面的代码：
```
NULL
```
想列出当前目录下所有的文本文件吗？请用下面的代码
```
@echo off
for %%i in (*.txt) do echo "%%i"
pause
```

想列出只用两个字符作为文件名的文本文件吗？(注:实际上这个代码是输出少于或等于两个字符作为文件名的文本文件)请用下面的代码：
```
@echo off
for %%i in (??.txt) do echo "%%i"
pause
```

题外话：
+ 1、列出当前目录下各种文件的方法，最简单的还是用dir命令，但是，从以上代码中，各位可以加深对for语句执行流程的理解(用到了通配符*和?)；
+ 2、注意：以上代码不能列出含有隐藏或系统属性的文件；(注：这里其实有一个很有趣的现象，windows中的系统文件一般具备两种属性——隐藏和系统；但是你如果测试的话就会发现，加上+s属性，但是不加+h的文件是可以被简单的for显示出来的。
例如：
```
@echo off
attrib +s 1.txt
For %%i in (*.txt) do Echo %%i
pause
```

这里的1.txt在结果中显示出来了。所以“以上代码不能列出含有隐藏或系统属性的文件”是不准确的，而因该说成“以上代码不能列出含有隐藏属性的文件”)


# 三、文本解析显神威：for /f 用法详解

## 前言  
for /f 是个十分强大的家伙。  
如果说，for语句是批处理中最强大的语句的话，那么，for /f 就是精华中的精华。  
for /f 的强大，和它拥有众多的开关密切相关。因为开关众多，所以用法复杂，本章将分成若干小节，为大家逐一介绍强大的 for /f 语句。  

for命令开关有很多，/L,/F,/R。这里仅对含有/F的for进行分析，这个可能是最常用的，也是最强的命令，主要用来处理文件和一些命令的输出结果。

### 1.命令格式：

（1）.FOR /F ["options"] %%i IN (file) DO command  
（2）.FOR /F ["options"] %%i IN ("string") DO command--**注意双引号**  
（3）.FOR /F ["options"] %%i IN ('command') DO command--**注意单引号**  

 

### 2.参数说明：

file代表一个或多个文件，可以使用通配符。  
string 代表字符串  
command代表命令  
["options"]选项有多个：  

eol=c           - 指定一个行注释字符，遇到c开头的行就忽略掉。  
skip=n          - 指定在文件开始时忽略的行数。  
delims=xxx      - 指定分隔符。默认是空格和TAB。  
  
tokens=x,y,m-n  -  
指每行的哪一个符号被传递到每个迭代的 for 本身。这会导致额外变量名称的分配。m-n格式为一个范围。通过 nth 符号指定 mth。如果符号字符串中的最后一个字符星号，那么额外的变量将在最后一个符号解析之后分配并接受行的保留文本。    

usebackq        - 1.把单引号字符串作为命令；2.允许中使用双引号扩起文件名称。  

## (1)为解析文本而生：for /f 的基本用法

所有的对象,无论是文件、窗体、还是控件，在所有的非机器语言看来，无外乎都是形如"c:\test.txt"、"CWnd"之类的文本信息；而所有的对象，具体的如ini文件中的某条配置信息、注册表中的某个键值、数据库中的某条记录…都只有转化为具有一定格式的文本信息，方可被代码识别、操 控。可以说，编程的很大一部分工作，都是在想方设法绞尽脑汁如何提取这些文本信息。

而提取文本信息，则是for /f的拿手好戏：读取文件内容；提取某几行字符；截取某个字符片段；对提取到的内容再切分、打乱、杂糅……只要你所能想到的花样，for /f 都会想方设法帮你办到，因为，for /f 就是被设计成专门用于解析文本的。

先来看个例子。  
假如有个文本文件test.txt，内容如下：  
[txt1]  
```
Hello,Xi'an
Hello,Shanxi
Hello Batch
```

那么，将如下代码保存为test.cmd，并放在test.txt同一目录下运行，将会在屏幕上原样显示test.txt的内容：  
[code4]  
```
@echo off
for /f %%i in (test.txt) do echo %%i
pause
```
[Result4]  
```
Hello,Xi'an
Hello,Shanxi
Hello
Press any key to continue . . .
```
（看如果什么也不加，其实是以空格符、回车符为分隔符。）
这段代码，主要是让你树立这样一种观念：读取文本文件的内容(注：改为“逐行分析文本文件的内容”，因为读取文本文件内容的方法命令有很多，比如重定向输入，又比如type/more/find/sort等命令)，请使用 for /f 语句！

进阶话题：for /f 语句是把整个test.txt一次性显示出来的？  
在这段代码中，虽然执行结果是把test.txt中的所有内容都显示出来了，貌似 for /f 语句是把整个test.txt一次性显示到屏幕上，实际上并非如此。  

无论for语句做何种变化，它的执行过程仍然遵循基本的for流程：依次处理每个元素，直到所有的元素都被处理为止。只不过在for /f语句中，这里的元素是指文件中的每一行，也就是说，for /f 语句是以行为单位处理文本文件的。这是一条极为重要的规则，在上一章中也强调过它的重要性，希望在接下来的学习过程中，你能时刻牢记这一原则，那么，很多问题将会迎刃而解。以下是验证这一说法的演示代码(在[code4]的基础上添加了&pause语句):  

[code5]
```
@echo off
for /f %%i in (test.txt) do echo %%i&pause
pause
```
## (2) 切分字符串的利器：delims=

还是[txt1]这段文本，把[code4]改造一下：  
[code6]
```
@echo off
for /f "delims=，" %%i in (test.txt) do echo %%i
pause
```
[result6]
```
Hello
Hello
Hello Batch
Press any key to continue . . .
```

结果，你惊奇地发现，每行第一个逗号之后的所有内容都不见了(如果有不存在逗号的行，则保留原样)，也就说，你成功地提取到了每行第一个逗号之前的所有内容！

也可以这么改：
[code6.1]
```
@echo off
for /f "delims=" %%i in (test.txt) do echo %%i
pause
```
[result6.1]
```
Hello,Xi'an
Hello,Shanxi
Hello Batch
Press any key to continue . . .
```

可以看到如果增加“delims=”，这样默认就是以回车符为分隔符。

如果别人给了你一个软件清单，每行都是"英文软件名(逗号)中文软件名"的格式，而你却只想保留英文名的时候，这段代码将是多么有用啊！再假设，有 这么一个IP文件，第一列是数字格式的IP地址，第二列是具体的空间地址，列与列之间用逗号分隔，而你想提取其中数字格式的IP，呵呵，我不说你也知道该 怎么办了吧？  
要是文本内容不是以逗号分隔，而是以其他符号分隔，那么，把"delims=,"的逗号换成相应的符号就可以了。  
在这里，我们引入了一个新的开关："delims=，"，它的含义是：以逗号作为被处理的字符串的分隔符号。  
在批处理中，指定分隔符号的方法是：添加一个形如 "delims=符号列表" 的开关，这样，被处理的每行字符串都会被符号列表中罗列出来的符号切分开来。  
需要注意的是：如果没有指定"delims=符号列表"这个开关，那么，for /f 语句默认以空格键或跳格键作为分隔符号。请把[txt1]中不同位置上的标点符号改为空格或跳格，再运行[code4]试试。  

进阶话题：如果我要指定的符号不止一个，该怎么办？  
在上面的讲解中，我提到了指定分隔符号的方法：添加一个形如"delims=符号列表"的开关。不知道你注意到没有，我的说法是"符号列表"而非"符号"，这是大有讲究的，因为，你可以一次性指定多个分隔符号！  
还是以[txt1]为例，把[code6]再改造一下  
[text7]
```
Hello,Xi'an
Hello,Shanxi
Hello Batch
Chiness! Good!
```
[code7]  
```
@echo off
for /f "delims=,!" %%i in (test.txt) do echo %%i
pause
```
[result7]
```
Hello
Hello
Hello Batch
Chiness
Press any key to continue . . .
```

我们可以把多个分隔符写在一块，这样就可以以","和"!"为分隔符。

需要注意的是：如果没有指定"delims=符号列表"这个开关，那么，**for /f 语句默认以空格键或跳格键作为分隔符号**。

## (3) 定点提取：tokens=

上一节在讲解 delims= 的时候，我一再强调 for /f 默认只能提取到第一节的内容，现在我们来思考一个问题：如果我要提取的内容不在第一节上，那怎么办？  
这回，就该轮到 tokens= 出马了。  
tokens= 后面一般跟的是数字，如 tokens=2，也可以跟多个，但是每个数字之间用逗号分隔，如 tokens=3,5,8，它们的含义分别是：提取第2节字符串、提取第3、第5和第8节字符串。注意，这里所说的“节”，是由 delims= 这一开关划分的，它的内容并不是一成不变的。

下面来看一个例子：
[txt2]
```
I have a dream, you have a dream, he has a dream, everybody have a dream!
```
对[txt2]这段文本，假设它们保存在文件test.txt中，如果我想提取“ you have a dream”这句话，该如何写代码呢？  
我们稍微观察一下[txt2]就会发现，如果以逗号作为切分符号，就正好可以把“学好批处理没商量”化为单独的一“节”，结合上一节的讲解，我们知 道，"delims=，" 这个开关是不可缺少的，而要提取的内容在以逗号切分的第3节上，那么，tokens= 后面的数字就应该是2了，最终的代码如下：  
[code8]
```
@echo off
for /f "delims=, tokens=2" %%i in (test.txt) do echo %%i
pause
```
[result]
```
 you have a dream
Press any key to continue . . .
```

如果我们现在要提取的不只一个“节”，而是多个，那又怎么办呢？比如，要提取以逗号切分的第2节和第4节字符串，是写成这样吗？  
[code9]
```
@echo off
for /f "delims=， tokens=2,4" %%i in (test.txt) do echo %%i
pause
```

运行批处理后发现，执行结果只显示了第2节的内容。  
原来，echo 后面的 %%i 只接收到了 tokens=2,5 中第一个数值2所代表的那个字符串，而第二个数值4所代表的字符串因为没有变量来接收，所以就无法在执行结果中显示出来了。  
那么，要如何接收 tokens= 后面多个数值所指代的内容呢？  
for /f 语句对这种情况做如下规定：  
如果 tokens= 后面指定了多个数字，如果形式变量为%%i，那么，第一个数字指代的内容用第一个形式变量%%i来接收，第二个数字指代的内容用第二个形式变量%%j来接收，第三个数字指代的内容用第三个形式变量%%k来接收……第N个数字指代的内容用第N个形式变量来接收，其中，形式变量遵循字母的排序，第N个形式变量具体是什么符号，由第一个形式变量来决定：如果第一个形式变量是%%i，那么，第二个形式变量就是%%j；如果第一个形式变量用的是%%x，那么，第二个 形式变量就是%%y。  

现在回头去看[code9]，你应该知道如何修改才能满足题目的要求了吧？修改结果如下：  
[code10]
```
@echo off
for /f "delims=， tokens=2,4" %%i in (test.txt) do echo %%i %%j
pause
```

如果有这样一个要求：显示[txt2]中的内容，但是逗号要替换成空格，如何编写代码？  
结合上面所学的内容，稍加思索，你可能很快就得出了答案：  
[code11]
```
@echo off
for /f "delims=， tokens=1,2,3,4,5" %%i in (test.txt) do echo %%i %%j %%k %%l %%m
pause
```

写完之后，你可能意识到这样一个问题：假如要提取的“节”数不是5，而是10，或者20，或者更多，难道我也得从1写到10、20或者更多吗？有没有更简洁的写法呢？  
答案是有的，那就是：如果要提取的内容是连续的多“节”的话，那么，连续的数字可以只写最小值和最大值，中间用短横连接起来即可，比如 tokens=1,2,3,4,5 可以简写为 tokens=1-5 。  
还可以把这个表达式写得更复杂一点：tokens=1,2-5，tokens=1-3,4,5，tokens=1-4,5……怎么方便就怎么写吧。  
大家可能还看到一种比较怪异的写法：  
[code12]
```
@echo off
for /f "delims=， tokens=1,*" %%i in (test.txt) do echo %%i %%j
pause
```
[result12]
```
I have a dream  you have a dream, he has a dream, everybody have a dream!
Press any key to continue . . .
```
结果，第一个逗号不见了，取代它的是一个空格符号，其余部分保持不变。  
其中奥妙就在这个星号上面。  
tokens=后面所接的星号具备这样的功能：字符串从左往右被切分成紧跟在\*之前的数值所表示的节数之后，字符串的其余部分保持不变，整体被\*所表示的一个变量接收。  
理论讲解是比较枯燥的，特别是为了严密起见，还使用了很多限定性的修饰词，导致句子很长，增加了理解的难度，我们还是结合[code12]来讲解一下吧。  
[txt2] 的内容被切分，切分符号为逗号，当切分完第一节之后，切分动作不再继续下去，因为 tokens=1,* 中，星号前面紧跟的是数字1；第一节字符串被切分完之后，其余部分字符串不做任何切分，整体作为第二节字符串，这样，[txt2]就被切分成了两节，分别 被变量%%i和变量%%j接收。  
以上几种切分方式可以结合在一起使用。不知道下面这段代码的含义你是否看得懂，如果看不懂的话，那就运行一下代码，然后反复揣摩，你一定会更加深刻地理解本节所讲解的内容的：  
[code13]
```
@echo off
for /f "delims=， tokens=1,3-4,*" %%i in (test.txt) do echo %%i %%j %%k %%l
pause
```

## (4) 跳过无关内容，直奔主题：skip=n

很多时候，有用的信息并不是贯穿文本内容的始终，而是位于第N行之后的行内，为了提高文本处理的效率，或者不受多余信息的干扰，for /f 允许你跳过这些无用的行，直接从第N+1行开始处理，这个时候，就需要使用参数 skip=n，其中，n是一个正整数，表示要跳过的行数。例如：  
[code14]
```
@echo off
for /f "delims=, tokens=2 skip=2" %%i in (test.txt) do echo %%i
pause
```
[text]
```
I have a dream, you have a dream, he has a dream, everybody have a dream!
111, 222, 333!
!!!, @@@, ###!
```
[result]
```
 @@@
Press any key to continue . . .
```

这段代码将跳过头两行内容，从第3行起显示test.txt中的信息, 以,为分隔符，取分割后的第二个参数。

## (5) 忽略以指定字符打头的行：eol=

 在cmd窗口中敲入：for /?，相关的解释为：  
 ```
 eol=c    -指一个行注释字符的结尾(就一个)
 ```
 ```
FOR /F "eol=; tokens=2,3* delims=, " %i in (myfile.txt) do @echo %i %j %k
会分析 myfile.txt 中的每一行，忽略以分号打头的那些行……
```
第一条解释狗屁不通，颇为费解：行注释字符的结尾是什么意思？“(就一个)”怎么回事？结合第二条解释，才知道eol有忽略指定行的功能。但是，这两条解释是互相矛盾的：到底是忽略以指定字符打头的行，还是忽略以指定字符结尾的行？  
实践是检验真理的唯一标准，还是用代码来检验一下eol的作用吧：  
[code15]
```
@echo off
for /f "eol=;" %%i in (test.txt) do echo %%i
pause
```
结果，那些以分号打头的行没有显示出来。  
由此可见，第二条解释是正确的，eol= 的准确含义是：忽略以指定字符打头的行。而第一条的“结尾”纯属微软在信口开河。  
那么，“(就一个)”又作何解释呢？  
试试这个代码：  
[code16]
```
@echo off
for /f "eol=,;" %%i in (test.txt) do echo %%i
pause
```

此时，屏幕上出现“此时不应有" ;"。”的报错信息。可见，在指定字符的时候，只能指定1个——在很多时候，我对这样的设计颇有微词而又无可奈何：为什么只能指定1个而不是多个？要忽略多个还得又是if又是findstr加管道来多次过滤，那效率实在太低下了——能用到的功能基本上都提供，但是却又做不到更好，批处理，你的功能为什么那么弱？  
不知道大家注意到没有，如果test.txt中有以分号打头的行，那么，这些行在代码[code14]的执行结果中将凭空消失。  
原来，for /f 语句是默认忽略以分号打头的行内容的，正如它默认以空格键或跳格键作为字符串的切分字符一样。(注：eol=;这种默认设置，在delims=;时变得无效。)  
很多时候，我们可以充分利用这个特点，比如，在设计即将用for读取的配置文件的时候，可以在注释文字的行首加上分号，例如在编写病毒文件查杀代码的时候，可以通过for语句来读取病毒文件列表，那么，病毒文件列表.ini这个配置文件可以这样写：  
```
;以下是常见的病毒文件，请见一个杀一个
;copyleft:没有
qq.exe
msn.exe
iexplore.exe
```
如果要取消这个默认设置，可选择的办法是：
+ 1、为eol=指定另外一个字符；
+ 2、使用 for /f "eol=" 语句，也就是说，强制指定字符为空，就像对付delims=一样。




参考链接：
https://www.cnblogs.com/achievegoals/p/9151523.html
