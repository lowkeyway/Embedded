# 不同编译器对变量类型的影响和结构体字节对齐

+ **题目：**

有如下CAT_s结构体定义，在一台64位的机器上，使用32位编译，Garfield 变量占用多少内存空间？64位编译又是如何？
```c
struct CAT_s{
  int ld;
  char Color;
  unsigned short Age;
  char *Name;
  void(*Jump)(void);
}Garfield;
``` 

+ **分析：**

这个问题主要考察了在不同编译器对变量类型分配空间大小和对齐问题。
1. 变量类型：

| Compiler | char | short | int | float | double | long | long long | char * | void * |
| :-----: | :----: | :----: | :-----: | :----: | :----: | :-----: | :----: | :----: | :----: |
|32 Bit |	1 |	2 |	4 |	4 |	8 |	4 |	8 |	4 |	4 |
|64 Bit |	1 |	2 |	4 |	4 |	8 |	4 |	8 |	8 |	8 |


总的来说，对于32位和64位的目标机器，需要做到对char/short/int/float/double/long/long long这类基本类型的大小保持向下（向32）兼容，所以只有指针的大小会跟着目标机器的寻址位宽改变。

2. 字节对齐

为什么需要字节对齐？是为了方便寻址，比如一个32位系统，PC指针每加1就要跨过4个字节的物理地址，相同道理，64位系统会跨过8个字节的物理地址。
所以，为了读写方便，结构体中的数据一般都会放在对应操作系统跨过字节的整数倍，如果不够一个位宽，则需要对其进行补零对齐。

+ **答案：**

使用32位编译器编译：16
使用64位编译器编译：24
