# C语言中的参数传递和返回值传递

## 参数传递

+ **__cdecl**

C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，由调用者负责把参数压入栈，最后也是由调用者负责清除栈的内容
+ **__stdcall**

StandardCall的缩写，是C++的标准调用方式：所有参数从右到左依次入栈，由调用者负责把参数压入栈，最后由被调用者负责清除栈的内容

## 返回值传递

1. 对于小于4个字节的数据函数将返回值存储在eax中。
2. 5~8个字节对象的情况调用惯例都是采用eax和edx的联合返回方式进行。
3. 大于8个字节的返回类型,用一下代码测试:

```C
typedef struct big_thing
{
    char buf[128];
}big_thing;

big_thing return_test()
{
    big_thing b;
    b.buf[] = 0;
    return b;
}

int main()
{
    big_thing n = return_test();
}
```

+ 首先main函数在栈额外开辟了一片空间，并将这块空间的一部分作为传递返回值的临时对象，这里称为temp
+ 将temp对象的地址作为隐藏参数传递个return_test函数
+ return_test 函数将数据拷贝给temp对象，并将temp对象的地址用eax传出。
+ return_test返回以后,mian函数将eax 指向的temp对象的内容拷贝给n。


4. 如果返回值的类型的尺寸太大，c语言在函数的返回时会使用一个临时的栈上内存作为中转，结果返回值对象会被拷贝两次。因而不到万不得已，不要轻易返回大尺寸对象。



**函数返回值为什么一般放在寄存器中，这主要是为了支持中断；如果放在堆栈中有可能因为中断而被覆盖。**


## 函数的堆栈帧

栈在程序运行中具有举足轻重的地位。最重要的，栈保存了一个函数调用所需要的维护信息，被称为**堆栈帧（Stack Frame）**，一个函数（被调函数）的堆栈帧一般包括下面几个方面的内容：
1. 函数参数，默认调用惯例情况下从右向左的顺序依次把参数压入栈中。由函数调用方执行。
2. 函数的返回地址，即调用方调用此函数（如call func1）的下一条指令的地址。函数调用方（call指令）执行。
3. 保存调用方函数的EBP寄存器，即将调用方函数的EBP压入堆栈，并令EBP指向此栈中的地址：pushl %ebp; movl %esp, %ebp。由被调函数执行。
4. 上下文：保存在函数调用过程中需要保持不变的寄存器（函数调用方的），如ebx，esi，edi等。由被调函数执行。
5. 临时变量，如非静态局部变量
