# 程序内存空间（代码段、数据段、堆栈段）

在冯诺依曼的体系结构中，一个进程必须有：代码段，堆栈段，数据段。

进程的虚拟地址空间图示如下：

<img src="https://github.com/lowkeyway/Embedded/blob/master/Software/Compile/pic/%E4%BB%A3%E7%A0%81%E6%AE%B5%E3%80%81%E6%95%B0%E6%8D%AE%E6%AE%B5%E3%80%81%E5%A0%86%E6%A0%88%E6%AE%B5.png">

## 堆栈段：

+ 为函数内部的局部变量提供存储空间。
+ 进行函数调用时，存储“过程活动记录”。
+ 用作暂时存储区。如计算一个很长的算术表达式时，可以将部分计算结果压入堆栈。

## 数据段（静态存储区）：

包括BSS段（Block Started by Symbol）的数据段。BSS段存储未初始化或初始化为0的全局变量、静态变量，具体体现为一个占位符，并不给该段的数据分配空间，只是记录数据所需空间的大小。数据段存储经过初始化的全局和静态变量。


举个例子，

1. 我们写一个test.c的文件：

```
  #include <stdio.h>
  #define DEBUG "debug"  
    
  int space[1024][1024];  
  int g_data = 1;                                                                                                                                                                                           
  int no_data = 0;  
    
  int main()  
  {  
    char *p_data = DEBUG;  
    static int s_data;
    printf("Hello World\n");
    return 1;
  } 
```

2. 然后用gcc编译它：

```
gcc test.c
```

3. 运行一下看是否OK：

```
lowkeyway@lowkeyway:/media/sf_ubuntu/code/my_code/test$./a.out 
Hello World
```

4. 用nm命令查看一下编译后的文件：

```
lowkeyway@lowkeyway:/media/sf_ubuntu/code/my_code/test$nm -n a.out 
                 w __gmon_start__
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
                 U __libc_start_main@@GLIBC_2.2.5
                 U puts@@GLIBC_2.2.5
00000000004003c8 T _init
0000000000400430 T _start
0000000000400460 t deregister_tm_clones
00000000004004a0 t register_tm_clones
00000000004004e0 t __do_global_dtors_aux
0000000000400500 t frame_dummy
0000000000400526 T main
0000000000400550 T __libc_csu_init
00000000004005c0 T __libc_csu_fini
00000000004005c4 T _fini
00000000004005d0 R _IO_stdin_used
00000000004005e8 r __GNU_EH_FRAME_HDR
0000000000400710 r __FRAME_END__
0000000000600e10 t __frame_dummy_init_array_entry
0000000000600e10 t __init_array_start
0000000000600e18 t __do_global_dtors_aux_fini_array_entry
0000000000600e18 t __init_array_end
0000000000600e20 d __JCR_END__
0000000000600e20 d __JCR_LIST__
0000000000600e28 d _DYNAMIC
0000000000601000 d _GLOBAL_OFFSET_TABLE_
0000000000601028 D __data_start
0000000000601028 W data_start
0000000000601030 D __dso_handle
0000000000601038 D g_data
000000000060103c B __bss_start
000000000060103c D _edata
0000000000601040 b completed.7594
0000000000601040 D __TMC_END__
0000000000601044 B no_data
0000000000601048 b s_data.2289
0000000000601060 B space
0000000000a01060 B _end
```

备注：
nm命令是linux下自带的特定文件分析工具，一般用来检查分析二进制文件、库文件、可执行文件中的符号表，返回二进制文件中各段的信息。
当我们有debug，查看二进制文件格式的时候，这时候就将用到一些特殊工具，linux下的nm命令就可以完全胜任(同时还有objdump和readelf工具，这里暂不作讨论)。

nm的常用命令

```
-A 或-o或 --print-file-name：打印出每个符号属于的文件
-a或--debug-syms：打印出所有符号，包括debug符号
-B：BSD码显示
-C或--demangle[=style]：对低级符号名称进行解码，C++文件需要添加
--no-demangle：不对低级符号名称进行解码，默认参数
-D 或--dynamic：显示动态符号而不显示普通符号，一般用于动态库
-f format或--format=format：显示的形式，默认为bsd，可选为sysv和posix
-g或--extern-only：仅显示外部符号
-h或--help：国际惯例，显示命令的帮助信息
-n或-v或--numeric-sort：显示的符号以地址排序，而不是名称排序
-p或--no-sort：不对显示内容进行排序
-P或--portability：使用POSIX.2标准
-V或--version：国际管理，查看版本
--defined-only：仅显示定义的符号，这个从英文翻译过来可能会有偏差，故贴上原文：

Display only defined symbols for each object file
```

## 5. 解析nm命令输出

我们知道：

+ 首先，前面那一串数字，指的就是地址，如果是二进制目标文件，指的就是逻辑地址，并非程序最后运行时的地址。
+ 然后，我们发现，每一个条目前面还有一个字母，类似'U','B','D等等，其实这些符号代表的就是当前条目所对应的内存所在部分
+ 最右边的就是对应的符号内容了

可以用man nm查看第二条中对应的U/B/D是什么含义：
```
A     ：符号的值是绝对值，不会被更改
B或b  ：未被初始化的全局数据，放在.bss段
D或d  ：已经初始化的全局数据
G或g  ：指被初始化的数据，特指small objects
I     ：另一个符号的间接参考
N     ：debugging 符号
p     ：位于堆栈展开部分
R或r  ：属于只读存储区
S或s  ：指为初始化的全局数据，特指small objects
T或t  ：代码段的数据，.test段
U     ：符号未定义
W或w  ：符号为弱符号，当系统有定义符号时，使用定义符号，当系统未定义符号且定义了弱符号时，使用弱符号。
？    ：unknown符号
```

结合nm输出以及nm命令的含义，我们可以得到以下信息：
1. 按照地址排序，先是T(代码段.test)和r（只读存储区），然后是D（已经初始化的全局数据 .data), 其次是B（未被初始化的全局数据.bss）
2. 像space/no_data/s_data没有初始化，或者初始化为0的都放在B区，g_data已经初始化的放在d区

注：
+ .bss是不占用.exe文件空间的，其内容由操作系统初始化（清零）；而.data却需要占用，其内容由程序初始化。
+ .data和.bss在加载时合并到一个Segment（Data Segment）中，这个Segment是可读可写的。



